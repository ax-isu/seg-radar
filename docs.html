<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<TITLE>Система "Радар"</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<CENTER>
<H1>Система "Радар"</H1>
<FONT SIZE="4"><I>Александр Балюк</I></FONT><BR>
<FONT SIZE="4">18&ndash;26 октября 2021 года</FONT>
</CENTER>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>

  <UL>
  <LI><A HREF="#toc1">1. Уточнения по заданию</A>
    <UL>
    <LI><A HREF="#toc2">1.1. Драйвер</A>
    <LI><A HREF="#toc3">1.2. Максимальное число одновременно наблюдаемых объектов</A>
    <LI><A HREF="#toc4">1.3. Потерянный объект</A>
    <LI><A HREF="#toc5">1.4. Экран</A>
    </UL>
  <LI><A HREF="#toc6">2. Общая архитектура системы</A>
    <UL>
    <LI><A HREF="#toc7">2.1. Хранилище</A>
    <LI><A HREF="#toc8">2.2. Диспетчер</A>
    <LI><A HREF="#toc9">2.3. Детектор</A>
    <LI><A HREF="#toc10">2.4. Экран</A>
    <LI><A HREF="#toc11">2.5. Вспомогательные типы</A>
    </UL>
  <LI><A HREF="#toc12">3. Модель диспетчера</A>
    <UL>
    <LI><A HREF="#toc13">3.1. Структурный аспект</A>
    <LI><A HREF="#toc14">3.2. Поведение диспетчера</A>
      <UL>
      <LI><A HREF="#toc15">3.2.1. Операция targetPosition</A>
      <LI><A HREF="#toc16">3.2.2. Операция handleLostTargets</A>
      </UL>
    </UL>
  <LI><A HREF="#toc17">4. Приложение Радар</A>
    <UL>
    <LI><A HREF="#toc18">4.1. Обработка подключения к серверу хранилища</A>
    </UL>
  <LI><A HREF="#toc19">5. Особенности реализации прототипа</A>
  </UL>

<P></P>
<HR NOSHADE SIZE=1>
<P></P>

<A NAME="toc1"></A>
<H1>1. Уточнения по заданию</H1>

<A NAME="toc2"></A>
<H2>1.1. Драйвер</H2>

<P>
Входит ли драйвер в состав системы, или является внешним объектом для системы, который передает ей сообщения через стандартный поток ввода/вывода?
</P>
<P>
Проще было бы считать, что драйвер не входит в состав системы, но мы пойдем другим путем и будем считать, что драйвер является частью системы, и вывод в стандартный поток выполняет система.
</P>

<A NAME="toc3"></A>
<H2>1.2. Максимальное число одновременно наблюдаемых объектов</H2>

<P>
Под максимальным числом объектов можно понимать максимальное число объектов, которые могут одновременно появиться в поле зрения радара, или максимальное число объектов, за которыми может следить система.
</P>
<P>
Будем считать, что это именно максимальное число объектов, за которыми может следить система, а в поле зрения радара может находиться и большее число объектов.
</P>

<A NAME="toc4"></A>
<H2>1.3. Потерянный объект</H2>

<P>
Объект будет считаться потерянным, если последний раз объект появлялся в поле зрения радара более, чем полсекунды тому назад.
</P>

<A NAME="toc5"></A>
<H2>1.4. Экран</H2>

<P>
На экране должно отображаться положение объектов в реальном времени.
На экран координаты объектов могут отправляться непосредственно с радара или из хранилища.
</P>
<P>
Будем считать, что на экран координаты объектов попадают из хранилища. В этом смысле экран можно считать внешней системой, запрашивающей данные из хранилища, и взаимодействующей с системой по тому же самому протоколу, что и другие внешние системы.
</P>

<A NAME="toc6"></A>
<H1>2. Общая архитектура системы</H1>

<P>
В разрабатываемой системе выделим три основных компонента (интерфейса): детектор (Detector), диспетчер (Dispatcher), хранилище (Storage).
</P>
<P>
<IMG ALIGN="middle" SRC="img/overview.png" BORDER="0" ALT="">
</P>

<A NAME="toc7"></A>
<H2>2.1. Хранилище</H2>

<P>
Хранилище функционирует независимо от остальных компонентов и предоставляет возможность, с одной стороны, помещать в себя данные (операция <CODE>store</CODE>), с другой стороны, получать из себя данные в формате JSON (операция <CODE>getObjects</CODE>). Также в хранилище предусмотрена операция <CODE>truncate</CODE>, очищающее его от устаревших данных.
</P>

<A NAME="toc8"></A>
<H2>2.2. Диспетчер</H2>

<P>
Диспетчер получает координаты объектов, обнаруженных детектором, с помощью операции <CODE>targetPosition</CODE>, фильтрует их таким образом, чтобы одновременно следить не более чем за десятью целями (ограничение в задании), и передает на хранение хранилищу.
</P>

<A NAME="toc9"></A>
<H2>2.3. Детектор</H2>

<P>
Детектор определяет координаты и идентификторы объектов и передает их диспетчеру. По каждому объекту координаты определяются не чаще, чем пять раз в секунду (ограничение в задании).
</P>

<A NAME="toc10"></A>
<H2>2.4. Экран</H2>

<P>
Как уже было сказано выше, экран обращается к хранилищу за координатами текущих объектов для их визуализации. Поскольку экран взаимодействует с системой "Радар" как внешняя система, то его проектирование и реализацию пока отложим.
</P>

<A NAME="toc11"></A>
<H2>2.5. Вспомогательные типы</H2>

<P>
Для хранения и передачи данных об обнаруженных объектах введем вспомогательные типы данных:
</P>

<OL>
<LI><CODE>Point</CODE> &mdash; структура, задающие координаты объекта <CODE>x</CODE> и <CODE>y</CODE>;
<LI><CODE>Label</CODE> &mdash; тип для хранения идентификторов объектов;
<LI><CODE>TimeStamp</CODE> &mdash; тип для хранения отметки времения получения данных об объекте;
<LI><CODE>State</CODE> &mdash; перечисление для хранения состояния объекта.
</OL>

<A NAME="toc12"></A>
<H1>3. Модель диспетчера</H1>

<P>
Диспетчер смоделируем более подробно.
</P>

<A NAME="toc13"></A>
<H2>3.1. Структурный аспект</H2>

<P>
Структурный аспект представлен на следующей диаграмме.
</P>
<P>
<IMG ALIGN="middle" SRC="img/dispatcher.png" BORDER="0" ALT="">
</P>
<P>
В основе управления отслеживаемыми объектами лежит структура <CODE>Tracker</CODE> (далее <I>трекер</I>), в которой может храниться информация об одном отслеживаемом объекте. Далее такие объекты будем называть <I>целями</I>. В трекере хранится идентификатор, координаты и время обновления информации о цели.
</P>
<P>
В диспетчер входит два контейнера: <I>пул трекеров</I> <CODE>trackerPool</CODE> и <I>список активных трекеров</I> <CODE>activeTrackers</CODE>.
</P>
<P>
Пул трекеров предназначен для хранения незадействованных трекеров и поддерживает две операции:
</P>

<UL>
<LI><CODE>pop</CODE> &mdash; извлечение трекера из пула;
<LI><CODE>push</CODE> &mdash; помещение трекера в пул.
</UL>

<P>
При извлечении трекера он сразу инициализируется нужным идентификатором, координатами и отметкой времени цели.
</P>
<P>
Список активных трекеров представляет собой ассоциативный массив STL, позволяющий быстро находить трекер по идентификатору цели.
</P>
<P>
В список активных трекеры попадают из пула. Изначально в пул помещается десять трекеров. Таким образом реализуется ограничение, при котором система может ослеживать одновременно не более десяти целей.
</P>

<A NAME="toc14"></A>
<H2>3.2. Поведение диспетчера</H2>

<P>
Диспетчер наследует и переопределяет операцию <CODE>targetPosition</CODE> от абстрактного класса <CODE>Dispatcher</CODE>.
Также в диспетчере реализована операция <CODE>handleLostTargets</CODE>, которая определяет потерянные цели, то есть цели, о которых давно (более полусекунды) не было данных. Операция <CODE>handleLostTargets</CODE> выполняется в отдельном потоке, который запускается в конструкторе диспетчера.
</P>

<A NAME="toc15"></A>
<H3>3.2.1. Операция targetPosition</H3>

<P>
Работа функции <CODE>targetPosition</CODE> представлена на следующей диаграмме.
</P>
<P>
<IMG ALIGN="middle" SRC="img/targetPosition.png" BORDER="0" ALT="">
</P>
<P>
Все действия выполняются в критической секции, чтобы избежать конфликтов с функцией <CODE>handleLostTargets</CODE>, которая выполняется в отдельном потоке.
</P>
<P>
Сначала по идентификатору определяем, отслеживается ли объект, координаты которого получены от детектора, каким-либо трекером. Если нет, то пытаемся извлечь из пула новый трекер и добавить к списку активных. Если же пул был пуст, то данный объект игнорируем, он не будет отслеживаться, по крайней мере пока.
</P>
<P>
Если же объект присутствует в списке активных трекеров (или был только что добавлен из пула), обновляем его координаты и отправляем обновленные данные в хранилище.
</P>
<P>
Критическая секция завершается только после помещения данных о цели в хранилище, поскольку операция <CODE>handleLostTargets</CODE> также осуществляет доступ к хранилищу, и потенциально может возникнуть конфликт.
</P>
<P>
С другой стороны предполагается, что от детектора данные поступают в одном потоке выполнения (не параллельно).
</P>

<A NAME="toc16"></A>
<H3>3.2.2. Операция handleLostTargets</H3>

<P>
Работа функции <CODE>handleLostTargets</CODE> представлена на следующей диаграмме.
</P>
<P>
<IMG ALIGN="middle" SRC="img/handleLostTargets.png" BORDER="0" ALT="">
</P>
<P>
В функции организован бесконечный цикл, каждая итерация которого выполняется после полусекундной задержки с момента завершения предыдущей итерации.
Действия каждой итерации выполняются в критической секции, поскольку в процессе работы может изменяться список активных трекеров, а также может выполняться запись в хранилище. В обоих случаях нужно избежать конфликта с операцией <CODE>targetPosition</CODE>.
</P>
<P>
Далее последовательно проходится список активных трекеров, и выявляются те цели, о которых информации не было более 0,5 секунды.
Каждый такой трекер извлекается из списка активных и отправляется обратно в пул, а в хранилище передается информация о том, что цель была потеряна.
</P>

<A NAME="toc17"></A>
<H1>4. Приложение Радар</H1>

<P>
В предыдущих разделах была описана модель системы "Радар". В процессе реализации прототипа системы потребовалось уточнить взаимодействие хранилища с внешними системами. Была выбрана реализация в виде TCP сервера на базе класса <CODE>QTcpServer</CODE>. В итоге, в приложении создаются четыре объекта: ранее упоминавшиеся детектор, диспетчер и хранилище, а также <I>сервер хранилища</I> <CODE>storageServer</CODE>.
</P>
<P>
<IMG ALIGN="middle" SRC="img/application.png" BORDER="0" ALT="">
</P>
<P>
При старте системы потребовалось также выделить отдельно операцию запуска детектора <CODE>start</CODE> в отдельном потоке, чтобы отделить её от потока обработки событий Qt. Последовательность операций при старте приложения представлена на следующей диаграмме взаимодейсвий.
</P>
<P>
<IMG ALIGN="middle" SRC="img/applicationStart.png" BORDER="0" ALT="">
</P>

<A NAME="toc18"></A>
<H2>4.1. Обработка подключения к серверу хранилища</H2>

<P>
При обработке очередного подключения к серверу хранилища вызывается функция <CODE>incomingConnection</CODE>, которая в отдельном потоке запускает фунцкию <CODE>serveConnection</CODE>, которая, собственно, и обрабатывает подключение.
</P>
<P>
<IMG ALIGN="middle" SRC="img/serveConnection.png" BORDER="0" ALT="">
</P>
<P>
При обработке очередного подключения в функции <CODE>serveConnection</CODE> создается экземпляр класса <CODE>QTcpSocket</CODE>, который связывается с TCP-сокетом подключения. Затем после ожидания готовности ввода (<CODE>waitForReadyRead</CODE>) из сокета читается строка (<CODE>readLine</CODE>). Предполагается, что строка содержит две отметки времени, разделенные пробелом. Они в качестве параметров передаются функции <CODE>getObjects</CODE> хранилища <CODE>Storage</CODE>. Результат функции отправляется в качестве ответа клиенту (<CODE>write</CODE>). После окончания отправки ответа (<CODE>waitForBytesWritten</CODE>) поток завершается.
</P>

<A NAME="toc19"></A>
<H1>5. Особенности реализации прототипа</H1>

<OL>
<LI>Детектор генерирует случайные объекты из 20 возможных с частотой 20 Гц, причем один объект появляется не чаще, чем 5 раз в секунду.
<LI>Логи в стандартный поток выводит объект хранилища, экземпляр класса <CODE>SimpleStorage</CODE>.
<LI>Диаграммы созданы в программе WhiteStarUML версии 5.4.5.0.
<LI>Текущий файл подготовлен в системе <A HREF="http://txt2tags.org/">txt2tags</A>.
<LI>Прототип разрабатывался с использованием Qt версии 4.8.6.
<LI>Проект выложен в репозиторий <A HREF="https://github.com/ax-isu/seg-radar">https://github.com/ax-isu/seg-radar</A>.
<LI>После запуска прототипа подключиться к хранилищу можно с помощью <CODE>telnet</CODE>, указав порт 9876.
</OL>

<!&ndash; html code generated by txt2tags 2.6 (http://txt2tags.org) &ndash;>
<!&ndash; cmdline: txt2tags -o docs.html docs.t2t &ndash;>
</BODY></HTML>
