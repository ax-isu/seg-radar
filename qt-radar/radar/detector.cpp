#include "detector.hpp"

#include <thread>
#include <cstdlib>
#include <ctime>
#include <chrono>

// Запуск детектора
void Detector::start() {
	
	// Детектор будет выдавать случайные координаты
	// случайному объекту из 20 доступных каждые 0,05 сек.
	
	// Тогда с вероятностью 1/2 каждый объект будет появляться
	// в любом полусекундном интервале, а значит, считаться
	// "потерянным" с вероятностью 1/2 (из-за реализации чуть меньше).
	
	// Объектов больше, чем максимальное число отслеживаемых целей,
	// значит некоторые цели диспетчеру придется игнорировать.
	
	std::string ids[] = {
		"Акира",
		"Кеико",
		"Мидори",
		"Наоми",
		"Сэкико",
		"Томоко",
		"Узэджи",
		"Фумико",
		"Хэруми",
		"Чинэтсу",
		"Шизука",
		"Юмико",
		"Акихиро",
		"Кеиджи",
		"Микайо",
		"Нобуюки",
		"Сэтоши",
		"Тсутому",
		"Хиройуки",
		"Ясухиро"
	};
	const size_t ids_size = sizeof(ids) / sizeof(ids[0]);
	std::srand(std::time(0));
	
	typedef std::chrono::high_resolution_clock clock;
	typedef std::chrono::time_point<clock> time_point;
	time_point time_points[ids_size] = { };
	
	// Запускаем бесконечный цикл, который будет делать 20 итераций в секунду.
	// На каждой итерации отправляем случайные координаты по случайному объекту.
	for ( ; ; ) {
		
		using namespace std::literals::chrono_literals;
		std::this_thread::sleep_for(50ms);
		
		// Берем случайные случайные координаты.
		double x = int(double(std::rand()) / RAND_MAX * 2000) / 1000.0 - 1;
		double y = int(double(std::rand()) / RAND_MAX * 2000) / 1000.0 - 1;
		
		// Текущее время.
		time_point now(clock::now());
		
		// Нам нужно поддерживать ограничение, что по одному объекту данные
		// передаются не чаще, чем 5 раз в секунду. Реализуем это в следующем цикле.
		// Попробуем не более 5 объектов. Если попадется тот, о котором отправляли
		// данные не менее, чем 0,2 секунды назад, отправим данные снова
		// и перейдем к следующей итерации объемлющего цикла.
		for ( int i = 5; i--; ) {
			
			// Определим случайно индекс идентификатора, который хотим отправить диспетчеру.
			int index = double(std::rand()) / RAND_MAX * ids_size;
			
			// Если для него отправляли данные не так давно, перейдем к следующему.
			if ( now < time_points[index] + 200ms )
				continue;
			
			// Сохраняем время и отправляем координаты диспетчеру.
			time_points[index] = now;
			dispatcher->targetPosition(ids[index], {x, y});
			
			// Обрываем цикл.
			break;
		}
		
	}
	
}
